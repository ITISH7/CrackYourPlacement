description question 287 leetcode
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.

 

Example 1:

Input: nums = [1,3,4,2,2]
Output: 2
Example 2:

Input: nums = [3,1,3,4,2]
Output: 3
Example 3:

Input: nums = [3,3,3,3,3]
Output: 3

approach 1
Visiting Method

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
       int size= nums.size();
       for(int i=0;i<size;i++){
        int index =abs( nums[i]);
        if(nums[index]<0){
             return index;
        }
       
        nums[index]*=-1;

       }
       return -1;
    }
};

approach 2
swapping the zero index

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
       while(nums[0]!=nums[nums[0]]){
        swap(nums[0],nums[nums[0]]);
       }
       return nums[0];
    }
};

approach 3
using binary search


class Solution {
public:
    int findDuplicate(vector<int>& nums) {
      int left=1;
      int right=nums.size()-1;
      while(left<right){
        int mid = left+(right-left)/2;
        int count=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]<=mid){
                count++;
            }
        }
        if(count>mid){
            right=mid;
        }
        else{
        left= mid+1;
        }
        }      
    }
};

approach 4
slow and fast pointer

class Solution {
public:
    int findDuplicate(vector<int>& nums) {
       int slow = nums[0];
       int fast = nums[0];
       do{
        slow=nums[slow];
        fast=nums[nums[fast]];
       }while(slow!=fast);
       slow=nums[0];
       while(slow!=fast){
        slow=nums[slow];
        fast=nums[fast];
       }
       return slow;
    }
};
